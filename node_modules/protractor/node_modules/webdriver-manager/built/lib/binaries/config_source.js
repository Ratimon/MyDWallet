"use strict";
const fs = require('fs');
const path = require('path');
const request = require('request');
const xml2js = require('xml2js');
const config_1 = require('../config');
const http_utils_1 = require('../http_utils');
class ConfigSource {
    constructor() {
        this.ostype = config_1.Config.osType();
        this.osarch = config_1.Config.osArch();
        this.out_dir = config_1.Config.getSeleniumDir();
    }
}
exports.ConfigSource = ConfigSource;
class XmlConfigSource extends ConfigSource {
    constructor(name, xmlUrl) {
        super();
        this.name = name;
        this.xmlUrl = xmlUrl;
    }
    getFileName() {
        try {
            fs.statSync(this.out_dir);
        }
        catch (e) {
            fs.mkdirSync(this.out_dir);
        }
        return path.resolve(this.out_dir, this.name + '-response.xml');
    }
    getXml() {
        let fileName = this.getFileName();
        let content = this.readResponse();
        if (content != null) {
            return Promise.resolve(content);
        }
        return this.requestXml(this.xmlUrl, this.opt_ignoreSSL, this.opt_proxy).then(text => {
            let xml = this.convertXml2js(text);
            fs.writeFileSync(fileName, text);
            return xml;
        });
    }
    readResponse() {
        let fileName = this.getFileName();
        try {
            let contents = fs.readFileSync(fileName).toString();
            let timestamp = new Date(fs.statSync(fileName).mtime).getTime();
            let now = Date.now();
            if (now - 36000000 < timestamp) {
                return this.convertXml2js(contents);
            }
        }
        catch (err) {
            return null;
        }
    }
    requestXml(url, opt_ignoreSSL, opt_proxy) {
        return new Promise((resolve, reject) => {
            let options = http_utils_1.HttpUtils.initOptions(url);
            options = http_utils_1.HttpUtils.optionsSSL(options, opt_ignoreSSL);
            options = http_utils_1.HttpUtils.optionsProxy(options, url, opt_proxy);
            let req = request(options);
            req.on('response', response => {
                if (response.statusCode === 200) {
                    // logger.info('curl -v ' + options.url);
                    let output = '';
                    response.on('data', (data) => {
                        output += data;
                    });
                    response.on('end', () => {
                        resolve(output);
                    });
                }
                else {
                    reject(new Error('response status code is not 200'));
                }
            });
        });
    }
    convertXml2js(xml) {
        let retResult = null;
        xml2js.parseString(xml, (err, result) => {
            retResult = result;
        });
        return retResult;
    }
}
exports.XmlConfigSource = XmlConfigSource;
class JsonConfigSource extends ConfigSource {
    constructor(name, jsonUrl) {
        super();
        this.name = name;
        this.jsonUrl = jsonUrl;
    }
    getFileName() {
        try {
            fs.statSync(this.out_dir);
        }
        catch (e) {
            fs.mkdirSync(this.out_dir);
        }
        return path.resolve(this.out_dir, this.name + '-response.json');
    }
}
exports.JsonConfigSource = JsonConfigSource;
class GithubApiConfigSource extends JsonConfigSource {
    constructor(name, url) {
        super(name, url);
    }
    /**
     * This is an unauthenticated request and since Github limits the rate, we will cache this
     * to a file. { timestamp: number, response: response }. We will check the timestamp and renew
     * this request if the file is older than an hour.
     */
    getJson() {
        let fileName = this.getFileName();
        let content = this.readResponse();
        if (content != null) {
            return Promise.resolve(JSON.parse(content));
        }
        else {
            return this.requestJson().then(body => {
                let json = JSON.parse(body);
                fs.writeFileSync(fileName, JSON.stringify(json, null, '  '));
                return json;
            });
        }
    }
    requestJson() {
        return new Promise((resolve, reject) => {
            let options = http_utils_1.HttpUtils.initOptions(this.jsonUrl);
            options = http_utils_1.HttpUtils.optionsSSL(options, this.opt_ignoreSSL);
            options = http_utils_1.HttpUtils.optionsProxy(options, this.jsonUrl, this.opt_proxy);
            options = http_utils_1.HttpUtils.optionsHeader(options, 'Host', 'api.github.com');
            options = http_utils_1.HttpUtils.optionsHeader(options, 'User-Agent', 'request');
            let req = request(options);
            req.on('response', response => {
                if (response.statusCode === 200) {
                    // logger.info('curl -v ' + options.url);
                    let output = '';
                    response.on('data', (data) => {
                        output += data;
                    });
                    response.on('end', () => {
                        resolve(output);
                    });
                }
                else {
                    reject(new Error('response status code is not 200'));
                }
            });
        });
    }
    readResponse() {
        let fileName = this.getFileName();
        try {
            let contents = fs.readFileSync(fileName).toString();
            let timestamp = new Date(fs.statSync(fileName).mtime).getTime();
            let now = Date.now();
            if (now - 36000000 < timestamp) {
                return contents;
            }
        }
        catch (err) {
            return null;
        }
    }
}
exports.GithubApiConfigSource = GithubApiConfigSource;
//# sourceMappingURL=config_source.js.map